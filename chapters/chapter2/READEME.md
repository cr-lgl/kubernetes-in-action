# 2. 도커와 쿠버네티스 첫걸음

```
2장에서 다루는 내용
 - 도커를 사용한 컨테이너 이미지 생성, 실행, 공유
 - 로컬에 단일 노드 쿠버네티스 클러스터 실행
 - kubectl CLI 클라이언트 설정과 사용
 - 쿠버네티스에서 애플리케이션의 배포와 수평 스케일링
```

## 2.1 도커를 사용한 컨테이너 이미지 생성, 실행, 공유

### 2.1.1 도커 설치와 Hello, World 턴테이너 실행하기

도커 설치: https://docs.docker.com/engine/install/

1. Hello World 컨테이너 실행
```
docker run busybox echo "Hello, world"
```

2. 백그라운드에 일어난 동작 이해하기

- busybox:latest 이미지가 로컬 컴퓨터에 존재하는지 체크
- 존재하지 않은 이미지인 경우, 도커 허브 레지스트리에서 이미지를 다운
- 도커가 이미지로부터 컨테이너를 생성
- 컨테이너 내부에서 명령어를 실행 후 프로세스를 중단하고, 컨테이너도 중지

3. 컨테이너 이미지에 버전 지정하기
모든 소프트웨어 패키지는 업데이트 되기 때문에 일반적으로 하나 이상의 버전이 존재한다.

도커는 동일한 이미지와 이름에 여러 개의 버전을 가질 수 있다.

이미지를 참조할 때, 명시적으로 태그를 지정하지 않으면, 도커는 latest 태그를 참조한 것으로 간주한다.

다른 버전의 이미지를 실행하려면 다음과 같이 이미지 이름에 태그를 같이 지정해야 한다.

```
docker run <image>:<tag>
```

### 2.1.2 간단한 node.js 애플리케이션 생성하기

```javascript
const http = require('http');
const os = require('os');

console.log("Kubia server starting...");

var handler = function (request, response) {
    console.log("Received request from " + request.connection.remoteAddress);
    response.writeHead(200);
    response.end("You've hit " + os.hostname() + "\n");
}

var www = http.createServer(handler);
www.listen(8080);
```

위 코드는 포트 8080으로 HTTP 서버를 시작하고, 서버는 모든 요청에 대해 상태 코드 200 OK와 "You've hit <hostname>"의 
텍스트를 HTTP 응답으로 한다.

반환되는 호스트 이름은 클라이언트가 HTTP 요청의 Host 헤더로 보낸 것이 아니라 서버의 실제 호스트 이름이다.

호스트 머신에서 실행되고 있음에도 호스트 머신의 호스트 이름을 바라보는 것이 아니라, 애플리케이션이 실행 중인 컨테이너
내부의 호스트 이름을 바라보는 것을 알 수 있다.

### 2.1.3 이미지를 위한 Dockerfile 생성

```dockerfile
FROM node:7

ADD app.js /app.js

ENTRYPOINT ["node", "app.js"]
```

애플리케이션을 이미지로 패키징하기 위한 Dockerfile이 필요하다.

### 2.1.4 컨테이너 이미지 생성

```
docker build -t kubia .
```

위 명령어를 실행하면 kubia라고 부르는 이미지를 빌드한다.

1. 어떻게 이미지가 빌드되는지 이해하기
- 빌드 프로세스는 도커 클라이언트가 수행하지 않는다.
- 대신 빌드 디렉터리의 전체 콘텐츠가 도커 데몬의 업로드되고 그곳에서 이미지가 빌드된다.
- 도커 클라이언트와 데몬은 같은 머신에 있을 필요는 없다.
- 리눅스가 아닌 OS에서 도커를 사용하는 경우 도커 클라이언트는 호스트 OS에 위치하고, 데몬은 가상머신 내부에서 실행된다.
- 빌드 디렉터리의 모든 파일이 도커 데몬에 업로드돼야 하기 때문에, 데몬이 로컬이 아닌 경우 업로드 시간이 다소 오래 걸릴 수 있다.
- 빌드 프로세스 동안 이미지가 사용자 컴퓨타에 저장돼 있지 않다면, 도커는 기본 이미지(node:7)를 퍼블릭 이미지 리포지터리(도커 허브)에서 가져온다.

2. 이미지 레이어에 관해 이해하기

busybox 예제를 실행하면서 이미지라는 것이 하나의 큰 바이너리 덩어리가 아니라 여러 개의 레이어로 구성된다는 것을 눈치챘을 것이다.
서로 다른 이미지가 여러 개의 레이어를 공유할 수 있기 때문에 이미지의 저장과 전송에 효과적이다.
   
   
예를 들어, 기본 이미지(node:7)를 바탕으로 다수의 이미지를 생성하더라도 기본 이미지를 구성하는 모든 레이어는 단 한 번만 저장될 것이다.
또한 이미지를 가져올 때도 도커는 각 레이어를 개별적으로 다운로드한다. 컴퓨터에 여러 개의 레이어가 이미 저장돼 있다면 도커는 저장되지 않은 레이어만 다운로드한다.


각 Dockerfile이 새로운 레이어를 하나만 생성한다고 생각할 수 있지만 그렇지 않다. 이미지를 빌드하는 동안 기본 이미지의 모든 레이어를 가져온 다음, 도커는 그 위에
새로운 레이어를 생성하고 app.js 파일을 그 위에 추가한다. 그런 다음 이미지가 수행될 때 수행돼야 할 명령을 지정하는 또 하나의 레이어를 추가한다.
이 마지막 레이어는 kubia:latest라고 태그를 지정한다.

이미지 빌드 프로세스가 완료되면 아래 명령어로 저장된 새로운 이미지를 확인할 수 있다.

```
docker images
```

3. Dockerfile을 이용한 이미지 빌드와 수종 빌드 비교하기

Dockerfile은 도커로 컨테이너 이미지를 생성하는 일반적인 방법이지만, 기존 이미지에서 컨테이너를 실행하고 컨테이너 내부에서 명렁어를 수행한 후
빠져나와 최종 상태를 새로운 이미지로 커밋하는 방법으로 이미지를 수동으로 생성할 수 있다.

이것은 Dockerfile로부터 빌드를 하는 것과 정확히 동일한 방법이지만, Dockerfile을 이용하는 것이 훨씬 반복 가능하고
이미지 빌드를 자동화할 수 있는 방법이다. 이는 모든 명령어를 다시 수종으로 입력할 필요 없이 Dockerfile만 변경하면 언제든지 이미지를
다시 빌드할 수 있기 때문이다.

### 2.1.5 컨테이너 이미지 실행

```
docker run --name kubia-container -p 8080:8080 -d kubia
```

kubia-container라는 이름의 새로운 컨테이너를 생성한다. 

http://localhost:8080으로 애플리케이션에 접근할 수 있다.

1. 애플리케이션 접근하기

```
curl localhost:8080
```

애플리케이션이 격리된 컨테이너 내부엫서 실행 중이기 때문에, 호스트 머신의 호스트 이름이 아닌 도커 컨테이너 ID를 호스트 이름으로 응답한다.

2. 실행 중인 모든 컨테이너 조회하기

```
docker ps
```

위 명령어를 실행하면, 실행 중인 모든 컨테이너를 조회해서 리스트를 확인할 수 있다.

3. 컨테이너에 관한 추가 정보 얻기

docker ps 명령어는 컨테이너의 기본 정보만 표시한다. 자세한 정보를 보려면 docker inspect를 사용한다.

```
docker inspect kubia-container
```

### 2.1.6 실행 중인 컨테이너 내부 탐색하기

1. 실행 중인 컨테이너 내부에서 셸 실행하기
```
docker exec -it kubia-container bash
```

2. 내부에서 컨테이너 탐색

```
ps aux
```

컨테이너 내부에서 위 명령어를 실행하면, 호스트 운영체제의 다른 프로세스를 탐색할 수 없는 걸 확인할 수 있다.

3. 호스트 운영체제에서 실행 중인 컨테이너에서 실행되는 프로세스 이해하기

```
ps aux | grep app.js
```

호스트 운영체제에서 위 명렁어를 실행하면, 컨테이너에서 실행 중인 프로세스도 확인할 수 있다. 이는 컨테이너에서 실행 중인 프로세스가 호스트 운영체제에서 
실행 중이라는 것을 증명한다. 주의 깊게 살펴봤다면 호스트와 컨테이너 내부에서 조회한 프로세스 ID가 다르다는 것을 발견했을 것이다. 컨테이너는 자체 리눅스 PID
네임스페이스를 사용하고 고유의 시퀸스 번호스를 가지고 완전히 분리된 프로세스 트리를 갖고 있다.

4. 격리된 컨테이너 파일시스템

격리된 프로세스를 가진 것과 마찬가지로 각 컨테이너는 격리된 파일시스템을 갖고 있다.

### 2.1.7 컨테이너 중지와 삭제

```
docker stop kubia-container
```
kubia-container 컨테이너를 중지한다. docker ps -a로 컨테이너는 여전히 존재함을 확인할 수 있다.

```
docker rm kubia-container
```
위 명령어로 컨테이너를 완전히 삭제할 수 있다.

### 2.1.8 이미지 레지스트리에 이미지 푸시

도커 허브는 이미지의 리포지터리 이름이 도커 허브 ID로 시작해야만 이미지를 푸시할 수 있다.

1. 추가 태그로 이미지 태그 지정

```
docker tag kubia cherryred5959/kubia
```

2. 도커 허브에 이미지 푸시하기

도커 허브에 이미지를 푸시하기 전에 docker login 명령을 이용해 사용자 ID로 로그인을 해야 한다.

```
docker push cherryred5959/kubia
```

3. 다른 머신에서 이미지 실행하기

```
docker run -p 8080:8080 -d cherryred5959/kubia
```

## 2.2 쿠버네티스 클러스터 설치

### 2.2.1 Minikube를 활용한 단일 노드 쿠버네티스 클러스터 실행하기

Minikube는 로컬에서 쿠버네티스를 테스트하고 애플리케이션을 개발하는 목적으로 단일  노드 클러스터를 설치하는 도구다.

https://minikube.sigs.k8s.io/docs/start/

```
brew install minikube
```

1. Minikube로 쿠버네티스 클러스터 시작하기

```
minikube start
```

2. 쿠버네티스 클라이언트 설치하기

쿠버네티스를 다루려면 kubectl CLI 클라이언트가 필요하다.

```
brew install kubectl
```   

3. 클러스터 작동 여부 확인과 kubectl로 사용하기

```
kubectl cluster-info
```

위 명령어로 클러스터가 동작 중임을 확인할 수 있다.

### 2.2.2 구글 쿠버네티스 엔진을 활용 관리형 쿠버네티스 클러스터 활용하기
완전한 다중 노드 쿠버네티스 클러스터를 설펴보려면 관리형 구글 쿠버네티스 엔진(GKE 클러스터)을 사용할 수 있다.
이 방법을 사용하면 모든 클러스터 노드와 네트워킹을 수동으로 설정할 필요가 없다.

1. 구글 클라우드 프로젝트 설정과 필요한 클라이언트 바이너리 다운로드
   
https://cloud.google.com/kubernetes-engine/docs/quickstart
   
2. 노드 세 개를 가진 쿠버네티스 클러스터 생성

```
gcloud container clusteres create kubia --num-nodes 3
```

3. 클로스터의 개념 이해하기

각 노드는 도커,Kubelet, kube-proxy를 실행한다. Kubectl 클라이언트 명렁어는 마스터 노드에서 실행 중인 쿠버네티스 API 서버로
REST 요청을 보내 클러스터와 상호작용한다.

4. 클러스터 노드를 조회해 클러스터 동작 상태 확인하기

```
kubectl get nodes
```

위 명렁어로 모든 종류의 쿠버네티스 오브젝트를 조회할 수 있다.

5. 오브젝트 세부 정보 가져오기

```
kubectl describe node minikube
```

위 명령어를 실행하면 CPU와 메모리, 시스템 정보, 노드에 실행 중인 컨테이너 등을 포함한 노드 상태를 보여준다.

kubectl describe node 명령어를 실행하면 모든 노드의 상세 정보가 출력된다.

### 2.2.3 kubectl의 alias와 명령줄 자동완성 설정하기

1. 별칭 설정하기

```
alias k=kubectl
```

~/.bashrc나 이에 준하는 파일(~/.zshrc)에 위 라인을 추가한다.

2. kubectl의 탭 완성 설정하기

https://kubernetes.io/docs/tasks/tools/included/optional-kubectl-configs-zsh/

```
echo 'source <(kubectl completion zsh)' >>~/.zshrc
echo 'complete -F __start_kubectl k' >>~/.zshrc
```

위 명령어를 실행하면 kubectl 탭 자동 완성을 할 수 있다.

## 2.2 쿠버네티스에 첫 번째 애플리케이션 실행하기

### 2.3.1 Node.js 애플리케이션 구동하기

```
kubectl run kubia --image=cherryred5959/kubia --port=8080 --generator=run/v1
```

--image=cherryred5959/kubia 부분은 실행하고자 하는 컨테이너 이미지를 명시하는 것이고, --port=8080 옵션은
쿠버네티스에 애플리케이션이 8080 포트를 수신 대기해야 한다는 사실을 알려준다.


마지막 플래그(--generator)는 보통은 사용하지 않지만, 여기에서는 쿠버네티스에서 디플로이먼트 대신 레플리케이션컨트롤러를 생성하기 때문에 사용했다.


레플리케이션컨트롤러란? https://nearhome.tistory.com/90

(`Flag --generator has been deprecated, has no effect and will be removed in the future.`, 현재 버전에서 작동하지 않음.)

```
kubectl run kubia --image=cherryred5959/kubia --port=8080 --restart=Never
```

https://stackoverflow.com/questions/52890718/kubectl-run-is-deprecated-looking-for-alternative

kubectl create를 미는 걸로 보인다.

1. 파드 소개

쿠버네티스는 개별 컨테이너들을 직접 다루지 않는다. 대신 함께 배치된 다수의 컨테이너라는 개념을 사용한다. 이 컨테이너의 그룹을 파드(Pod)라고 한다.
파드는 하나 이상의 밀접하게 연관된 컨테이너의 그룹으로 같은 워커 노드에서 같은 리눅스 네임스페이스로 합께 실행된다. 각 파드는 자체 IP, 호스트 이름, 프로세스 
등이 있는 논리적으로 분리된 머신이다. 애플리케이션은 단일 컨테이너로 실행되는 단일 프로세스일 수도 있고, 개별 컨테이너에서 실행되는 주 애플리케이션 프로세스와 
부가적으로 도와주는 프로세스로 이뤄질 수도 있다. 파드에서 실행 중인 모든 컨테이너는 동일한 논리적인 머신에서 실행하는 것처럼 보이는 반면, 다른 파드에 실행 중인
컨테이너는 같은 워커 노드에서 실행 중이라 할지라도 다른 머신에서 실행 중인 것으로 나타난다.

2. 파드 소개

컨테이너는 독립적인 쿠버네티스 오브젝트가 아니기 때문에 개별 컨테이너를 조회할 수 없다. 대신 파드를 조회해야 한다.

```
kubectl get pods
```

3. 백그라운드에서 일어난 동작 이해하기

- 이미지를 빌드해 도커 허브에 푸시한다.
- kubectl 명령어를 실행하면 쿠버네티스의 API 서버로 REST HTTP 요청을 전달하고 클러스터에 새로운 레플리케이션컨트롤러 오브젝트를 생성한다.
- 레플리케이션컨트롤러는 새 파드를 생성하고 스케줄러에 의해 워커 노드 중 하나에 스케줄링이 된다.
- 해당 워커 노드의 Kubelet은 파드가 스케줄링됐다는 것을 보고 이미지가 로컬에 없다면, 도커에게 레지스트리에서 특정 이미지를 풀하도록 지시한다.
- 이미지를 다운로드 후 도커는 컨테이너를 생성하고 실행한다.

스케줄링이라는 용어는 파드가 특정 노드에 할당됨을 의미한다. 파드는 즉시 실행된다. 스케줄링이라는 용어의 의미처럼 미래의 특정 시간에 실행됨을 의미하는 것이 아니다.

### 2.3.2 웹 애플리케이션에 접근하기

각 파드는 자체 IP를 가지고 있지만 이 주소는 클러스터 내부에 있으며 외부에서 접근이 불가능하다.
LoadBalancer 유형의 서비스를 생성하면 외부 로드 밸런서가 생성되므로 로드 밸런서의 퍼블릭 IP를 통해 파드에 연결할 수 있다.

1. 서비스 오트젝트 생성하기

```
kubectl expose rc kubia --type=LoadBalancer --name kubia-http
```
kubectl run 명령어는 더 이상 레플리케이션컨트롤러 없이 파드를 생성하기 때문에, 위 명령어는 유효하지 않다.

```
kubectl expose pod kubia --type=LoadBalancer --name kubia-http
```
https://stackoverflow.com/questions/64306744/error-when-trying-to-expose-a-docker-container-in-minikube

2. 서비스 조회하기

```
kubectl get services
```

위 명령어로 새로 생성된 kubia-http라는 서비스를 확인할 수 있다.

3. External IP를 이용해 서비스 접근하기

```
minikube servcie kubia-http
```

자세히 살펴보면 파드 이름을 호스트 이름으로 사용한다. 앞서 언급했듯이 각 파드는 자체 IP 주소와 호스트 이름을 가진 별도의 독립 머신처럼 동작한다.

### 2.3.3 시스템의 논리적인 부분

1. 파드와 컨테이너의 이해

파드는 하나 이상의 컨테이너를 갖고 있고, 자체의 고유한 사설 IP 주소와 호스트 이름을 갖는다.

2. 레플리케이션컨트롤러의 역할 이해

항상 정확히 하나의 파드 인스턴스를 실행하도록 지정한다. 보통 레플리케이션컨트롤러는 파드를 복제하고 항상 실행 상태로 만든다. 여기에서는 파드이 레플리카를 지정하지
않았기 때문에 파드를 하나만 생성했다. 어떤 이유로든 파드가 사라진다면 레플리케이션컨트롤러는 사라진 파드를 대체하기 위해 새로운 파드를 생성한다.

3. 서비스가 필요한 이유

파드는 일시적이다. 파드는 언제든 사라질 수 있다. 이것이 서비스가 필요한 이유다, 항상 변경되는 파드의 IP 주소 문제와 여러 개의 파드를 단일 IP와 포트의 쌍으로 
노출시키는 문제를 해결한다.

### 2.3.4 애플리케이션 수평 확장

```
kubectl get replicationcontrollers
```

컨트롤러가 없다고 한다. 이유는 위에서 말한 것 처럼 kubectl run이 기본적으로 pod만 생성하기 때문이다.

```
kubectl delete pods kubia
kubectl apply -f replication.yml
kubectl delete service kubia-http
kubectl expose rc kubia --type=LoadBalancer --name kubia-http
```

이 방법으로 레플리케이션 컨트롤러를 생성 후 다시 진행한다.

DESIRED 열은 레플리케이션컨트롤라가 유지해야 할파드의 레플리카 수를 보여주는 반면, CURRENT 열은 현재 실행 중인 파드의 실제 수를 나타낸다.

1. 의도하는 레플리카 수 늘이기

```
kubectl scale rc kubia --replicas=3
```

쿠버네티스가 어떤 액션을 수행해야 하는지 정확하게 알려주는 대신에 시스템의 의도하는 상태를 선언적으로 변경하고 쿠버네티스가 실제 현재 상태를 검사해 의도한 상태로 
조정한다. 쿠버네티스의 전체 기능은 이와 동일한 방식으로 돌아간다.

2. 스케일 아웃 결과 보기

```
kubectl get rc
```

```
kubectl get pods
```

조회하면 3개로 변경된 것을 확인할 수 있다.


애플리케이션 자체에서 수평 확장을 지원하도록 만들어야 한다는 것을 유념하자. 쿠버네티스가 마법처럼 애플리케이션을 확장 가능하게 만들어주진 않으며, 단지 애플리케이션의
스케일업이나 스케일다운을 간단하게 만들어줄 뿐이다.

3. 서비스 호출 시 모든 파드가 요청을 받는지 확인

```
minikube service kubia-http
```

요청이 무작위로 다른 파드를 호출하고 있다.

### 2.3.5 애플리케이션이 실행 중인 노드 검사하기

1. 파드를 조회할 때 파드 IP와 실행 중인 노드 표시하기

```
kubectl get pods -o wide
```

파드 IP와 실행 중인 노드를 표시한다.

2. kubectl describe로 파드 세부 정보 살펴보기

```
kubectl describe pod kubia-hczji
```

파드의 상세 정보를 확인할 수 있다.

### 2.3.6 쿠버네티스 대시보드 소개

```
kubectl cluster-info | grep dashboard
```

Minikube는 아래 명령어로 실행이 가능하다.

```
minikube dashboard
```

## 2.4 요약

첫 실습을 통해 쿠버네티스가 사용하기 복잡한 플랫폼이 아니라는 것을 알게 됐고(?), 모든 기능을 깊이 있게 배울 준비가 됐다.

- 공개된 컨테이너 이미지를 풀하고 실행할 수 있다.
- 애플리케이션을 컨테이너 이미지로 패키징하고 원격 이미지 레지스트리에 이미지를 푸시해 누구나 사용할 수 있게 한다.
- 실행 중인 컨테이너에 접속한 환경을 알 수 있다.
- GKE에 다중 노드 쿠버네티스 클러스터를 설정할 수 있다.
- 쿠버네티스 클러스터의 노드, 파드, 서비스, 레플리케이션컨트롤러를 조회하고 검사할 수 있다.
- 쿠버네티스에 컨테이너를 실행하고 클러스터 외부에서 접근 가능하게 할 수 있다.
- 파드, 레플리케이션컨트롤러, 서비스가 어떻게 연관돼 있는지 기본 개념을 이해할 수 있다.
- 레플리케이션 컨트롤러의 레플리카 수를 변경해 애플리케이션을 수평으로 확장할 수 있다.
- Minikube나 GKE의 웹 기반 쿠버네티스 대시보드에 접근할 수 있다.
